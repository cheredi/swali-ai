{
  "scalability": {
    "title": "Scalability",
    "description": "Building systems that handle increased load",
    "concepts": [
      {
        "name": "Vertical Scaling (Scale Up)",
        "description": "Adding more power to existing machines (CPU, RAM, storage)",
        "pros": "Simple, no code changes needed",
        "cons": "Has limits, single point of failure, expensive",
        "when_to_use": "Early stage, simple applications, databases that can't scale horizontally"
      },
      {
        "name": "Horizontal Scaling (Scale Out)",
        "description": "Adding more machines to distribute load",
        "pros": "Theoretically unlimited, fault tolerant, cost effective",
        "cons": "Complex, requires load balancing, data consistency challenges",
        "when_to_use": "High traffic systems, cloud-native apps, stateless services"
      }
    ]
  },
  "load_balancing": {
    "title": "Load Balancing",
    "description": "Distributing requests across multiple servers",
    "concepts": [
      {
        "name": "Round Robin",
        "description": "Distribute requests sequentially across servers",
        "pros": "Simple, even distribution",
        "cons": "Doesn't consider server load or capacity",
        "when_to_use": "Homogeneous servers with similar capacity"
      },
      {
        "name": "Least Connections",
        "description": "Route to server with fewest active connections",
        "pros": "Better for varying request durations",
        "cons": "More overhead to track connections",
        "when_to_use": "Long-lived connections, varying response times"
      },
      {
        "name": "IP Hash",
        "description": "Route based on client IP hash",
        "pros": "Session affinity, consistent routing",
        "cons": "Uneven distribution possible",
        "when_to_use": "Stateful applications, sticky sessions needed"
      },
      {
        "name": "Weighted Round Robin",
        "description": "Round robin with weights based on server capacity",
        "pros": "Accounts for different server capabilities",
        "cons": "Requires manual weight configuration",
        "when_to_use": "Heterogeneous server fleet"
      }
    ]
  },
  "caching": {
    "title": "Caching",
    "description": "Storing frequently accessed data for faster retrieval",
    "concepts": [
      {
        "name": "Cache-Aside (Lazy Loading)",
        "description": "Application checks cache first, loads from DB on miss",
        "pros": "Only caches what's needed, resilient to cache failures",
        "cons": "Cache miss penalty, potential stale data",
        "when_to_use": "Read-heavy workloads, data doesn't change often"
      },
      {
        "name": "Write-Through",
        "description": "Write to cache and DB simultaneously",
        "pros": "Cache always fresh, consistent",
        "cons": "Write latency, cache may have unused data",
        "when_to_use": "When consistency is critical"
      },
      {
        "name": "Write-Behind (Write-Back)",
        "description": "Write to cache, async write to DB",
        "pros": "Low write latency, batching possible",
        "cons": "Data loss risk if cache fails",
        "when_to_use": "High write throughput, eventual consistency OK"
      },
      {
        "name": "Cache Eviction Policies",
        "description": "LRU (Least Recently Used), LFU (Least Frequently Used), FIFO",
        "pros": "Automatic memory management",
        "cons": "May evict useful data",
        "when_to_use": "LRU is most common, LFU for frequency-based access"
      }
    ]
  },
  "databases": {
    "title": "Database Design",
    "description": "Choosing and designing data storage solutions",
    "concepts": [
      {
        "name": "SQL vs NoSQL",
        "description": "Relational vs non-relational databases",
        "sql_pros": "ACID, complex queries, joins, mature",
        "sql_cons": "Scaling harder, schema changes difficult",
        "nosql_pros": "Horizontal scaling, flexible schema, fast writes",
        "nosql_cons": "Limited queries, eventual consistency",
        "when_to_use": "SQL for transactions/relationships, NoSQL for scale/flexibility"
      },
      {
        "name": "Database Sharding",
        "description": "Partitioning data across multiple databases",
        "pros": "Horizontal scale, fault isolation",
        "cons": "Complex queries, rebalancing difficulty",
        "sharding_strategies": [
          "Hash-based",
          "Range-based",
          "Directory-based"
        ]
      },
      {
        "name": "Replication",
        "description": "Copying data across multiple nodes",
        "types": [
          "Master-Slave",
          "Master-Master",
          "Synchronous",
          "Asynchronous"
        ],
        "pros": "High availability, read scaling",
        "cons": "Consistency challenges, replication lag"
      }
    ]
  },
  "cap_theorem": {
    "title": "CAP Theorem",
    "description": "Consistency, Availability, Partition Tolerance trade-off",
    "concepts": [
      {
        "name": "CAP Theorem",
        "description": "In a distributed system, you can only guarantee 2 of 3: Consistency, Availability, Partition Tolerance",
        "consistency": "Every read receives the most recent write",
        "availability": "Every request receives a response",
        "partition_tolerance": "System continues despite network failures",
        "practical_choices": [
          "CP: Consistency + Partition Tolerance (MongoDB, HBase)",
          "AP: Availability + Partition Tolerance (Cassandra, DynamoDB)"
        ]
      },
      {
        "name": "Consistency Models",
        "description": "Different levels of data consistency",
        "types": [
          "Strong Consistency: Reads always see latest write",
          "Eventual Consistency: Will converge to latest write eventually",
          "Causal Consistency: Causally related writes seen in order"
        ]
      }
    ]
  },
  "message_queues": {
    "title": "Message Queues",
    "description": "Asynchronous communication between services",
    "concepts": [
      {
        "name": "Message Queue Basics",
        "description": "Decouple producers and consumers with async messaging",
        "pros": "Decoupling, buffering, async processing, reliability",
        "cons": "Added complexity, potential message loss",
        "examples": [
          "RabbitMQ",
          "Apache Kafka",
          "Amazon SQS"
        ]
      },
      {
        "name": "Pub/Sub Pattern",
        "description": "Publishers send to topics, subscribers receive from topics",
        "pros": "Fan-out, decoupling, scalable consumers",
        "cons": "Message ordering challenges",
        "when_to_use": "Event broadcasting, microservices communication"
      }
    ]
  },
  "cdn": {
    "title": "Content Delivery Network",
    "description": "Distributed network for delivering content",
    "concepts": [
      {
        "name": "CDN Basics",
        "description": "Cache content at edge locations near users",
        "pros": "Lower latency, reduced origin load, improved availability",
        "cons": "Cache invalidation, cost, complexity",
        "what_to_cache": [
          "Static assets",
          "API responses",
          "Dynamic content with low TTL"
        ]
      },
      {
        "name": "Push vs Pull CDN",
        "description": "How content gets to edge servers",
        "push": "You upload to CDN, good for static content",
        "pull": "CDN fetches from origin on demand, good for dynamic"
      }
    ]
  },
  "api_design": {
    "title": "API Design",
    "description": "Designing clean, scalable APIs",
    "concepts": [
      {
        "name": "REST API Principles",
        "description": "Representational State Transfer design",
        "principles": [
          "Use HTTP methods correctly (GET, POST, PUT, DELETE)",
          "Resource-based URLs (/users/123, not /getUser?id=123)",
          "Stateless requests",
          "Use proper status codes (200, 201, 400, 404, 500)",
          "Version your API (/v1/users)"
        ]
      },
      {
        "name": "Rate Limiting",
        "description": "Limiting request frequency per client",
        "algorithms": [
          "Token Bucket",
          "Leaky Bucket",
          "Fixed Window",
          "Sliding Window"
        ],
        "when_to_use": "Protect against abuse, ensure fair usage"
      },
      {
        "name": "Pagination",
        "description": "Returning large datasets in chunks",
        "types": [
          "Offset-based",
          "Cursor-based"
        ],
        "best_practice": "Cursor-based for large, frequently changing data"
      }
    ]
  }
}